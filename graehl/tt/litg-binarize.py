#!/usr/bin/env pypy
usage="""
no args: lines from stdin are permutations (0 for first element)
1 arg = n : all permutations of length n are used as inputs.
>1 arg : indices for a single permutation are taken from arguments

returns an LTG binarization sequence for the permutation if there is one.
"""

"""
    *** why this is useful: I'm not sure. This seems to just answer some arcane
question about how strings and their permutations can be sycnrhonously derived
by a type of LTG grammar (1-state, 1 terminal and 1 optional NT at a time). The
computation is analogous to that performed in ITG-binarizing SCFG rules by
considering the alignments of their variables. But SCFG-1 rules can only have
one nonterminal anyway. And as for terminals, they're no problem if you have
states as you normally do in binarization e.g.

    to binarize:
    X -> abXd, Xef
    use:
    X -> aY, Y
    Y -> bZ, Ze
    Z -> Xd, Xf
    where Y and Z only occur in the lhs of the given two rules above

    that is, there's no problem with the terminals unless you want to impose the
constraint that the LTG derivation generate at the same time those words that
were actually word-aligned in the data (which is a reasonable desire if you want
to score things like LM and lex-smoothing early). the unaligned terminals can
simply be generated in free FST-like left->right order (generate all of one
side, then all of the other, or move at an even pace left->right through both
strings).

    *** future improvements: memoize in order to jump more than one left or
right at a time. will this actually give a speedup? do the analysis first. what
may give linear time if we don't have it already: if it's possible to
immediately decide where the 0->p[0] goes in the derivation (i.e. not guess the
center point c first)
"""

import sys,os


stdout=os.getenv('showall',False)
pretty=os.getenv('pretty',True)
showperm=os.getenv('showperm',pretty)
showcenter=os.getenv('showcenter',pretty)

from dumpx import *

def ltg_bin(perm):
    """
    *** input: perm=[0,1,4,2,3] a permutation of [0,1,...,max] - think of this
as a funny word:word alignment if you like (every word is 1:1 aligned)

    *** output: returns None if the original and permuted sequence
[0,1,....,max] can't be synchronously generated by a 1-state LTG (with at most
2 symbols and 1 NT on the source and target rhs) grammar.

     otherwise, returns a list l of [<>()]* - start at some index
c=center_of_ltg_bin(l) (the smallest possible - leftmost), then take the next
input symbol to the left or right, with <> inverting the output side, () leaving
it alone. this is an ltg derivation where the ith source and the perm[i]th in
the target are generated in the same step; rules are all of:

    X -> i X, p[i] X ('[')
    X -> X i, X p[i] (']')
    X -> i X, X p[i] ('<')
    X -> X i, p[i] X ('>')
    plus a trivial X -> (c,p[c]) (c)
    the rules are applied in the sequence given, bottom up
    (so the c rule is the last applied, top down)

    *** algorithm: guess that the spine of the derivation starts at each
position in the permutation. one (or more) of these will grow outward covering
synchronous contiguous spans in both source and target, until everything is
covered. when there are 2 choices which direction to grow, either can be
taken. we greedily grow left (in source) first. (a,b) is the covered
(doubly-closed, inclusive) source span and (x,y) is the covered target
(projection through perm) span.  whenever we fail, we know the center c is not
in (a,b). because of this, the algorithm is linear (trying every center c might
be quadratic)

    """

    p=[int(x) for x in perm]
#    dump('ltg_bin(%s)'%p)
    n=len(p)
    if (n==0 or min(p)!=0 or max(p)!=n-1):
        raise Exception("expected args, or lines to stdin, of at least 1 space-separated indices (permutations of >=1 elements notated e.g. 0 2 1 of the ints 0...max) - you supplied %s min=%s max=%s"%(perm,min(p),max(p)))
    if n==1:
        return []
    return ltg_bin_try_centers(p)

def center_of_ltg_bin(bin):
    return sum(1 for x in bin if x=='<' or x=='[')

def ltg_bin_try_centers(p):
    n=len(p)
    c=0 # center of LTG derivation
    while c<n:
        # inclusive (a,b) and (x,y)
        a=c
        b=c
        x=p[c]
        y=x
        bi=[]
        while True: # greedily grow covered span starting from c
            a2=a-1
            x2=x-1
            y2=y+1
#            dump('covered: (%s..%s..%s) -> (%s..%s) with bin=%s'%(a,c,b,x,y,bi))
            if a2>=0:
                pa=p[a2] # try growing covered input to left
#                dump('[< %s at %s covering up to (%s,%s)'%(pb,a2,x2,y2))
                if pa==x2:
                    bi.append('[')
                    a=a2
                    x=x2
                    continue
                if pa==y2:
                    bi.append('<')
                    a=a2
                    y=y2
                    continue
            b2=b+1
            if b2<n:
                pb=p[b2] # try growing covered input to right
#                dump('%s at %s >] covering up to (%s,%s)'%(pb,b2,x2,y2))
                if pb==x2:
                    bi.append('>')
                    b=b2
                    x=x2
                    continue
                if pb==y2:
                    bi.append(']')
                    b=b2
                    y=y2
                    continue
            break
        if a==0 and b==n-1:
            assert(x==0 and y==n-1)
            return bi
        c=b+1 # proved: if center exists, it must exist past the region (a,b) that includes our trial c
    return None

n_perm=0
n_perm_ltg_bin=0
def print_ltg_bin(perm,out=sys.stdout):
    if out is not None and showperm:
        out.write(' '.join(map(str,perm))+' = ')
    d=ltg_bin(perm)
    global n_perm,n_perm_ltg_bin
    n_perm+=1
    if d is not None:
        n_perm_ltg_bin+=1
        if out is not None:
            if showcenter: out.write(str(center_of_ltg_bin(d)))
            for x in d:
                out.write(x)
    if out is not None:
        out.write('\n')

def print_stats(out=sys.stderr):
    out.write('%s out of %s permutations (%s) were LTG-binarizable.\n'%(n_perm_ltg_bin,n_perm,float(n_perm_ltg_bin)/n_perm))

# pypy doesn't support itertools.permutations
def permute_in_place(a):
    'a is a list. yield all shuffled versions of it, starting w/ sorted'
    a.sort()
    yield list(a)
    if len(a) <= 1:
        return
    first = 0
    last = len(a)
    while 1:
        i = last - 1
        while 1:
            i = i - 1
            if a[i] < a[i+1]:
                j = last - 1
                while not (a[i] < a[j]):
                    j = j - 1
                a[i], a[j] = a[j], a[i] # swap
                r = a[i+1:last]
                r.reverse()
                a[i+1:last] = r
                yield list(a)
                break
            if i == first:
                a.reverse()
                return

def main(argv):
    if len(argv)==1:
        for p in permute_in_place(range(0,int(argv[0]))):
            print_ltg_bin(p,sys.stdout if stdout else None)
    elif len(argv):
        print_ltg_bin(argv)
    else:
        for line in sys.stdin:
            print_ltg_bin(line.split())
    print_stats()

if __name__ == "__main__":
    main(sys.argv[1:])


