<html><head>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Further Development</title>
<link rel="stylesheet" href="files/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.70.1">
<link rel="start" href="index.html" title="Chapter&nbsp;1.&nbsp;Boost.Coroutine">
<link rel="up" href="index.html" title="Chapter&nbsp;1.&nbsp;Boost.Coroutine">
<link rel="prev" href="design.html" title=" Design Rationale">
<link rel="next" href="details.html" title=" Details">
</head><body link="#0000ff" alink="#0000ff" bgcolor="white" text="black" vlink="#840084">
<table width="100%" cellpadding="2">
<tbody><tr><td valign="top"><img alt="boost.png (6897 bytes)" src="files/boost.png" width="277" height="86"></td>
<td align="center"><a href="http://www.boost.org/">Home</a></td>
<td align="center"><a href="http://www.boost.org/doc/libs">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="http://www.boost.org/users/index.html">More</a></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="design.html"><img src="files/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="files/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="files/home.png" alt="Home"></a><a accesskey="n" href="details.html"><img src="files/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both;">
<a name="coroutine.todo"></a> Further Development</h2></div></div></div>
<a name="todo.introduction"></a><h4>
<a name="id2629247"></a>Introduction</h4>
<p>
The main reason behind the development of Boost.Coroutine has been to
find a solution to the inversion control problem in event
driven web servers. From there the library has evolved to a general
coroutine library, whose usefulness goes beyond event driven
applications.</p>
<p>
Both developing the library and writing the documentation have been a
great learning exercise. The authors feels that it has only scratched
the possibilities of coroutine oriented design.</p>
<p>
Here are presented some useful additions to the library that have not
been added yet for lack of time, lack of a complete understanding of
the problem or both.</p>
<a name="todo.pipelining"></a><h4>
<a name="id2629274"></a>Pipelining</h4>
<p>
The <a href="producer_consumer1.html" title=" Example: the producer/consumer pattern">producer/consumer example</a>
briefly mention the possibility of pipelining coroutines. This could
be a powerful way of composing coroutines (and function objects in
general), and should be explored further. This is not necessarily
confined to this library though.</p>
<a name="todo.output_iterators"></a><h4>
<a name="id2629299"></a>Output iterators</h4>
<p>
The <a href="">generator</a> class template provides an input iterator interface
behind coroutines. For symmetry an output iterator interface is
conceivable.</p>
<a name="todo.generator_caching"></a><h4>
<a name="id2629322"></a>Generator caching</h4>
<p>
With the current implementation, a compiler cannot optimize (for
example by inlining the coroutine in the caller) across a context
switch barrier. It might be useful thus to do more work between
context switches. This can be accomplished by returning more than one
value at a time.</p>
<p>
Currently the user must apply this optimization by hand, and both the
caller and the callee must be aware of it. Boost.Coroutine might
provide a way to do this transparently.</p>
<a name="todo.context_caching"></a><h4>
<a name="id2629344"></a>Context caching</h4>
<p>
Creating a coroutine requires dynamically allocating both the
coroutine implementation and the coroutine stack. This could be a
performance hit if coroutines are created and destroyed
frequently. Unfortunately a normal custom allocator cannot be used
because on some systems it is not possible to create the internal
coroutine implementation and stack on user provided memory. Thus a
context and stack caching system should be devised.</p>
<a name="todo.future_allocator"></a><h4>
<a name="id2629364"></a>Future allocator</h4>
<p>
A <a href="">future</a> internal implementation is heap allocated. Futures should
be considered cheap object to create, so it makes sense to provide the
ability to specify an allocator if allocation becomes a bottleneck. An
allocator that uses memory from the coroutine stack would be useful,
and may be even the default. This would match well the future usage
that requires a future not to outlive the owning coroutine.</p>
</div>
<table width="100%"><tbody><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2006 Giovanni P. Deretta</small></td>
</tr></tbody></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="design.html"><img src="files/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="files/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="files/home.png" alt="Home"></a><a accesskey="n" href="details.html"><img src="files/next.png" alt="Next"></a>
</div>
</body></html>
