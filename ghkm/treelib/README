treelib 0.2.3
Bryant Huang
7/8/04

This package contains classes for reading, writing, and operating with
Radu and Collins parse trees. Other utility classes may be added in
the future.

The folder is organized as follows:

/              build scripts and other miscellaneous files
  doc/         documentation generated by Doxygen
  include/
    treelib/   header files, dependencies, and source code
  lib/         library dependencies and treelib static library
  src/
    treelib/   source code
  test/        test driver programs

This library depends on PCRE and the C++ wrapper PCRE++. The necessary
header files are found in the 'include/treelib' folder and the libraries are
found in the 'lib' folder.

The test driver programs demonstrate how to use this library in your
own programs. For more detailed instructions, read the Getting Started
section below.

[GETTING STARTED]
The easiest way to get started in using this package is to follow
these steps:

1. Create a folder for your project and go inside.
2. Retrieve treelib from CVS by running 'cvs checkout treelib'. This will
create a subfolder called 'treelib'.
3. In your project's source file, include 'treelib/Tree.h'.
4. Add the required functionality to your program. Take for example
the following bare program:

    #include <iostream>
    #include <treelib/Tree.h>

    using namespace std;
    using namespace treelib;

    int main(int argc, char **argv)
    {
      Tree tr;              // create an a new tree
      string str = "(NP~2~2 -1.00000 (DT this) (NN man) )";
      tr.read(str);         // read in a raw Radu parse tree
      cout << tr << endl;   // print the tree in Radu format

      return 0;
    }

Notice that the treelib classes are found in the treelib namespace,
so either you must declare 'using namespace treelib;' at the top as in
the above example or simply qualify each usage of a treelib class with
the scope resolution operator, e.g., 'treelib::Tree'.

5. To compile, run:

    g++ -Itreelib/include -c -o myprog.o myprog.cpp

6. To link, run:

    g++ -static -o myprog myprog.o -Ltreelib/lib -ltreelib -lpcre++ -lpcre

7. Run your program!

[PARSER FORMATS]
Out of the box, treelib supports both Radu and Collins parser
formats. The default Tree constructor initializes a Radu tree:

  Tree tr;

You may pass an argument to the constructor to specify which type:

  Tree tr1(RADU);      // equivalent to the default constructor above
  Tree tr2(COLLINS);

There is separate code that reads in and writes out both types of
parser formats. The appropriate functions will be called depending
upon the parser format you specify.

[TREELIB USAGE]
Tree_ is a templated class, so you must specify the type of tree node
you are using. Typically in your own projects, you won't use Tree_
directly. I have included a typedef of Tree_<TreeNode> which is simply
called Tree. This is the most basic tree which contains all the
necessary functionality. Henceforth I will refer to Tree rather than
Tree_<TreeNode>.

In the case where you wish to add additional information to each tree
node, i.e., TreeNode is not expressive enough, you can create your own
extension. An example of such an extension can be found at
test/treelib-test-ext.cpp and UTree.h. UTree.h contains a class
definition for UTreeNode and a typedef definition for UTree. UTree is
a Tree_<UTreeNode>. UTreeNode inherits directly from TreeNode but adds
the additional field 'isUnaryParent', which marks if a node has only
one child. In this example, the constructor, operator<<, and
toStream() functions are overridden so that this additional field is
accommodated and even outputted. The treelib-test-ext.cpp file
contains a markUnaryParents() function that operates on a field
specific to this UTree extension by calling
setIsUnaryParent(). Following this procedure will allow you to use
more fully annotated tree nodes in the trees which you read in. Since
UTree is still a Tree_, you can use the identical read() function as
with Tree.

[TREE CLASS USAGE]
The Tree_ class is a wrapper around Kasper Peeter's tree.hh STL-like
tree class. You may find further documentation and examples at
<http://www.damtp.cam.ac.uk/user/kp229/tree/>. Consulting the
'tree_example.cc' and 'test_tree.cc' sample files there should be
helpful.

The most straightforward method of operating on the tree is using one
of the available iterators: Tree::pre_order_iterator,
Tree::post_order_iterator, and Tree::sibling_iterator. The latter is
used to iterate through nodes at the same level in the tree. These
iterators function very much like standard STL iterators.

You may store and access data at each tree node using the accessors
and mutators of the TreeNode class. For example, to retrieve out the
inside probability of the head node of a Tree tr, I would call
tr.begin()->getInsideProb(). Similarly, you could set that value to
0.5 by calling tr.begin()->setInsideProb(0.5).

Some tips:
- for a Tree tr: tr.begin() returns an iterator to the top node of
the tree; tr.end() returns an iterator to the last node of the tree
- to access the first child of a node pointed to by an iterator it,
call tr.child(it, 0)
- learn the differences between the set_head, insert*, append*
functions
- tr.is_valid() is an easy way to check if a Tree was built properly
- tr.empty() returns whether the Tree is empty
- tr.size() counts the total number of nodes in the Tree

[ADDITIONAL FUNCTIONALITY]
<< Lowercasing >>
When a tree is read in, its leaves are automatically lowercased by
default. In order to disable this feature, set the enableLowercasing()
mutator to false *before* calling read(). For example:

  Tree tr;
  tr.enableLowercasing(false);
  tr.read("...");

<< Tokenization Conversion >>
The Tree class also comes with two functions that will convert the
tokenization of the leaves from one format to another:

  convertPTBToDecoder(): PTB -> decoder
  convertDecoderToPTB(): decoder -> PTB

PTB stands for Penn Treebank and is the general tokenization format
used by parsers trained on the PTB (Radu, Collins, etc.). Decoder is
the format used by the alignment template system and other internal
systems. Calling either one of these functions after calling read()
will automatically transform them to the specified tokenization, for
example:

  Tree tr;
  tr.read("...");
  tr.convertPTBToDecoder();

<< Printing Leaves >>
The most straightforward way to print just the leaves of a tree (the
words of the parse tree sentence) is to call Tree's function
toString(). 

[BUILDING]
SCons, a replacement for make, is used to build the library and test
programs. If SCons is installed (it should be on the HPC cluster),
simply type 'scons' to build. Type 'scons lib' to build only the
library and 'scons test' to build only the test
programs. Alternatively, you can run 'build.sh' to manually build
both.

The library is outputted to the 'lib' folder. The test programs are
outputted in the 'test' folder. Sample parse tree files
'radu-sample.tree' and 'collins-sample.tree' are also found in that
'test' folder.

[DOCUMENTATION]
For documentation of the treelib API (generated by Doxygen), view
doc/index.html.
